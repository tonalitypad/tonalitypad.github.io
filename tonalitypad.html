<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Tonality Pad</title>
<style>
* {
	font-family: "Lucida Console", Monaco, monospace;
}
#editor {
	border: 1px solid black;
	border-radius: 5px;
	padding: 2px;
	width: 796px;
	min-height: 298px;
	height: calc(100vh - 358px);
}
#controls {
	width: 800px;
	height: 32px;
	font-size: 24px;
	margin-top: 5px;
	margin-bottom: 5px;
}
textarea, #highlights {
	width: 800px;
	min-height: 296px;
	height: calc(100vh - 360px);
	margin: 0;
	border: 0;
	padding: 2px;
	font-size: 14pt;
	line-height: 18pt;
	background-color: transparent;
	border-radius: 0;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow: auto;
	position: absolute;
	resize: none;
	left: 11px;
}
#highlights {
	pointer-events: none;
	color: transparent;
}
#grid {
    width: 793px;
    margin-bottom: 8px;
    background-color: black;
    padding: 3px 3px 20px 6px;
    border-radius: 12px;
}
.row {
	margin-bottom: 2px;
}
.row:nth-child(even) {
	margin-left: 30.5px;
}
.clear {
	clear: both;
}
.cell {
	width: 58px;
	height: 33.49px; /* 58*sqrt(3)/3 */
	line-height: 33.49px;
	background-color: white;
	border-radius: 1px;
	font-size: 28px;
	text-align: center;
	margin-right: 3px;
	margin-bottom: 0px;
	margin-top: 16.74px; /* 58*sqrt(3)/6 */
	float: left;
	font-weight: bold;
}
.cell::before, .cell::after {
	content: "";
	width: 0;
	display: block;
	border-left: 29px solid transparent;
	border-right: 29px solid transparent;
}
.cell::before {
	border-bottom: 16.74px solid white;
	margin-top: -16.3px;
}
.cell::after {
	border-top: 16.74px solid white;
	margin-top: -0.5px;
}
.cell.active::before {
	border-bottom: 16.74px solid lime;
}
.cell.active::after {
	border-top: 16.74px solid lime;
}
#highlights .active, .cell.active {
	background-color: lime;
}
#highlights span {
	border-radius: 5px;
}
#highlights .erroneous {
	background-color: #f44;
}
#highlights .dissonant {
	background-color: #aaa;
}
#highlights .active.dissonant {
	background-color: #0a0;
}
#playButton, .blockedWhilePlaying {
	cursor: pointer;
}
#playControls.playing .blockedWhilePlaying {
	cursor: not-allowed;
}
#recordIndicator {
	width: 24px;
	text-align: center;
	color:red;
	display: inline-block;
}
#copiedTooltip {
	font-size: 14pt;
	position: absolute;
	margin-top: 1px;
	margin-left: -6px;
	padding: 2px;
	border-radius: 7px;
	background-color: black;
	color: white;
	cursor: default;
	text-wrap: nowrap;
	visibility: hidden;
	opacity: 0;
	transition: opacity 0.2s;
}
#copiedTooltip::before {
	content: "";
	border-width: 6px;
	border-style: solid;
	border-color: transparent;
	border-right: 6px solid black;
	display: inline-block;
	margin-top: 7px;
	margin-left: -13.5px;
	position: absolute;
}
#copiedTooltip.visible {
	visibility: visible;
	opacity: 1;
}
span.narrow {
	margin: -3px;
}
#waveforms span {
	cursor: pointer;
	padding: 5px;
	border-radius: 6px;
	padding-bottom: 0;
	font-weight: bold;
}
#waveforms span.selected {
	background-color: black;
	color: white;
}
</style>
</head>

<body onload="refreshHighlights()">

<div id="grid">
<div class="row">
	<div class="cell">G‚∏ó</div>
	<div class="cell">D‚∏ó</div>
	<div class="cell">A‚Åª</div>
	<div class="cell">E‚Åª</div>
	<div class="cell">B‚Åª</div>
	<div class="cell">F‚ôØ</div>
	<div class="cell">C‚ôØ</div>
	<div class="cell">G‚ôØ</div>
	<div class="cell">D‚ôØ</div>
	<div class="cell">A‚ôØ‚Å∫</div>
	<div class="cell">E‚ôØ‚Å∫</div>
	<div class="cell">B‚ôØ‚Å∫</div>
	<div class="cell">FùÑ™‚Ä°</div>
	<div class="clear"></div>
</div>
<div class="row">
	<div class="cell">B<span class="narrow">‚ô≠</span>‚∏ó</div>
	<div class="cell">F‚Åª</div>
	<div class="cell">C‚Åª</div>
	<div class="cell">G‚Åª</div>
	<div class="cell">D‚Åª</div>
	<div class="cell">A</div>
	<div class="cell">E</div>
	<div class="cell">B</div>
	<div class="cell">F‚ôØ‚Å∫</div>
	<div class="cell">C‚ôØ‚Å∫</div>
	<div class="cell">G‚ôØ‚Å∫</div>
	<div class="cell">D‚ôØ‚Å∫</div>
	<div class="clear"></div>
</div>
<div class="row">
	<div class="cell">G<span class="narrow">‚ô≠</span>‚∏ó</div>
	<div class="cell">D<span class="narrow">‚ô≠</span>‚∏ó</div>
	<div class="cell">A<span class="narrow">‚ô≠</span>‚Åª</div>
	<div class="cell">E<span class="narrow">‚ô≠</span>‚Åª</div>
	<div class="cell">B<span class="narrow">‚ô≠</span>‚Åª</div>
	<div class="cell">F</div>
	<div class="cell">C</div>
	<div class="cell">G</div>
	<div class="cell">D</div>
	<div class="cell">A‚Å∫</div>
	<div class="cell">E‚Å∫</div>
	<div class="cell">B‚Å∫</div>
	<div class="cell">F‚ôØ‚Ä°</div>
	<div class="clear"></div>
</div>
<div class="row">
	<div class="cell">BùÑ´‚∏ó</div>
	<div class="cell">F<span class="narrow">‚ô≠</span>‚Åª</div>
	<div class="cell">C<span class="narrow">‚ô≠</span>‚Åª</div>
	<div class="cell">G<span class="narrow">‚ô≠</span>‚Åª</div>
	<div class="cell">D<span class="narrow">‚ô≠</span>‚Åª</div>
	<div class="cell">A<span class="narrow">‚ô≠</span></div>
	<div class="cell">E<span class="narrow">‚ô≠</span></div>
	<div class="cell">B<span class="narrow">‚ô≠</span></div>
	<div class="cell">F‚Å∫</div>
	<div class="cell">C‚Å∫</div>
	<div class="cell">G‚Å∫</div>
	<div class="cell">D‚Å∫</div>
	<div class="clear"></div>
</div>
<div class="row">
	<div class="cell">GùÑ´‚∏ó</div>
	<div class="cell">DùÑ´‚∏ó</div>
	<div class="cell">AùÑ´‚Åª</div>
	<div class="cell">EùÑ´‚Åª</div>
	<div class="cell">BùÑ´‚Åª</div>
	<div class="cell">F<span class="narrow">‚ô≠</span></div>
	<div class="cell">C<span class="narrow">‚ô≠</span></div>
	<div class="cell">G<span class="narrow">‚ô≠</span></div>
	<div class="cell">D<span class="narrow">‚ô≠</span></div>
	<div class="cell">A<span class="narrow">‚ô≠</span>‚Å∫</div>
	<div class="cell">E<span class="narrow">‚ô≠</span>‚Å∫</div>
	<div class="cell">B<span class="narrow">‚ô≠</span>‚Å∫</div>
	<div class="cell">F‚Ä°</div>
	<div class="clear"></div>
</div>
</div>

<div id="controls">
	<div style="float:left" id="playControls">
		<span onclick="skipToStart()" style="cursor: pointer">‚è™</span>
		<span onclick="playSong()" id="playButton">‚ñ∂Ô∏è</span>
		<span class="blockedWhilePlaying" onclick="startRecording()" id="recordButton">‚è∫</span>
		<span id="recordIndicator" style="display:none" title="Download audio file once playback stops">‚Ä¢</span>
		<button style="cursor: pointer; font-size: 14pt" onclick="shareOnGithub()">Post on GitHub</button>
		<span class="blockedWhilePlaying" onclick="shareLink()" id="shareLinkButton">#Ô∏è‚É£</span>
		<span id="copiedTooltip">Copied link</span>
	</div>
	<div style="float:right; text-align: right" id="waveforms">
		<span onclick="setWaveform(this)" id="w_sine">‚óØ</span>
		<span onclick="setWaveform(this)" id="w_triangle">‚ñ≥</span>
		<span onclick="setWaveform(this)" id="w_square">‚ñ¢</span>
		<span onclick="setWaveform(this)" id="w_pulse" style="font-weight:normal">‚¨®</span>
		<span onclick="setWaveform(this)" id="w_superpulse">‚úß</span>
		<span onclick="setWaveform(this)" id="w_sawtooth">‚òÜ</span>
	</div>
	<div class="clear"></div>
</div>
<div id="editor">
<div id="highlights"></div>
<textarea id="song" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" oninput="refreshHighlights()" onscroll="scrollEditor(this, event)">This won't work without Javascript!</textarea>
</div>

<script>
// Constants:
const MIDDLE_C = 264;
const NOTE_BREAK = 0.1;
const NOISE_BREAK = 0.25;
const BREAK_MAX_MS = 100;
const FADEOUT_MS = 100;
const BASE_VOLUME = 0.1;
const RECORDING_GAIN = 3;
const INSTRUMENT_LETTERS = {
	s: "sine",
	t: "triangle",
	q: "square",
	p: "pulse",
	u: "superpulse",
	w: "sawtooth"
};
const VOLUME_ADJUSTMENT = {
	sine: 16/9,
	triangle: 4/3,
	square: 3/4,
	pulse: 1,
	superpulse: 4/3,
	sawtooth: 1
};
const NOTE_REGEX = "([ABCDEFGROX])([#b@+o-]*)([',]*)([0123456789]*)([.]*)(:+|~?)";
const WHITE_NOTES = {C:0, D:2, E:4, F:5, G:7, A:9, B:11};
const JUST_INTONATION = {C:1, D:9/8, E:5/4, F:4/3, G:3/2, A:5/3, B:15/8};
const CHROMATIC_SEMITONE = 25/24;
const SYNTONIC_COMMA = 81/80;
const STANDALONE_CHARS = "[/]{}|";
const ELEMENTS = {
	highlights: document.getElementById("highlights"),
	song: document.getElementById("song"),
	waveforms: document.getElementById("waveforms"),
	playControls: document.getElementById("playControls"),
	playButton: document.getElementById("playButton"),
	recordButton: document.getElementById("recordButton"),
	recordIndicator: document.getElementById("recordIndicator"),
	shareLinkButton: document.getElementById("shareLinkButton"),
	copiedTooltip: document.getElementById("copiedTooltip")
};
// Global state representing the current playback:
const PLAYBACK_STATE = {
	playing: false, // Whether it is currently playing
	waveform: void(0), // Selected waveform, used if none is specified in the notation 
	recording: false, // Whether it is currently recording
	timeouts: [], // Currently active timeouts
	tones: {} // Currently sounding notes
};

// -----
// Highlighting:

function sanitize(string) {
	return string
		.replaceAll("&", "&amp;")
		.replaceAll("<", "&lt;")
		.replaceAll(">", "&gt;")
		.replaceAll('"', "&quot;")
		.replaceAll("'", "&apos;");
}

function parseTextByTokens(text) {
	let output = "";
	let tokenIndex = 0;
	let spaceLast = !!text;
	for (let i=0; i<text.length; i++) {
		let cr = text[i];
		let c = sanitize(cr);
		if (STANDALONE_CHARS.includes(cr)) {
			if (tokenIndex) {
				output += "</span>";
			}
			output += "<span id=\"ht_" + tokenIndex + "\">" + c + "</span>";
			tokenIndex++;
			spaceLast = true;
		} else if (cr.match(/\s/)) {
			if (spaceLast) {
				output += c;
			} else {
				output += "</span>" + c;
			}
			spaceLast = true;	
		} else {
			if (spaceLast) {
				output += "<span id=\"ht_" + tokenIndex + "\">" + c;
				tokenIndex++;
				spaceLast = false;
			} else {
				output += c;
			}
		}
	}
	if (text[text.length-1] === "\n") {
		output += "\n";
	}
	if (tokenIndex && !spaceLast) {
		output += "</span>";
	}
	return output;
}

function refreshHighlights() {
	if (PLAYBACK_STATE.playing) {
		stop();
	}
	ELEMENTS.highlights.innerHTML = parseTextByTokens(ELEMENTS.song.value);
}

function scrollEditor(element, event) {
	let position = event.target.scrollTop;
	ELEMENTS.highlights.scrollTo(0, position);
	if (position >= ELEMENTS.highlights.scrollTop) {
		element.scrollTo(0, ELEMENTS.highlights.scrollTop);
		event.preventDefault();
	}
}

function setHighlighting(tokenIndex, status) {
	let tokenSpan = document.getElementById("ht_" + tokenIndex);
	if (tokenSpan) {
		if (status === 3) {
			tokenSpan.classList.add("dissonant");
		} else if (status === 2) {
			tokenSpan.classList.add("erroneous");
		} else if (status === 1) {
			tokenSpan.classList.add("active");
		} else if (status === 0) {
			tokenSpan.classList.remove("active");
		}
	}
}

function displayErrors(compilationErrors) {
	for (let i=0; i<compilationErrors.length; i++) {
		setHighlighting(compilationErrors[i], 2);
	}
}

function displayDissonances(dissonances) {
	for (let i=0; i<dissonances.length; i++) {
		setHighlighting(dissonances[i], 3);
	}
}


// -----
// Grid display:

(function(){
	// Set IDs on cells in grid
	let cells = document.getElementsByClassName("cell");
	for (let i=0; i<cells.length; i++) {
		let cell = cells[i];
		let text = cell.innerText.toLowerCase();
		let id = "cell_" + text[0] + (
				text.includes("ùÑ™") ? "ss" :
				text.includes("‚ôØ") ? "s" :
				text.includes("‚ô≠") ? "f" :
				text.includes("ùÑ´") ? "ff" : ""
			) + (
				text.includes("‚Ä°") ? "pp" :
				text.includes("‚Å∫") ? "p" :
				text.includes("‚Åª") ? "m" :
				text.includes("‚∏ó") ? "mm" : ""
			);
		cell.id = id;
	}
})();

function activateCell(noteName) {
	let cell = document.getElementById("cell_" + noteName);
	if (cell) {
		cell.dataset.activation = 1+parseInt(cell.dataset.activation || "0");
		cell.classList.add("active");
	}
}

function deactivateCell(noteName) {
	let cell = document.getElementById("cell_" + noteName);
	if (cell) {
		cell.dataset.activation = parseInt(cell.dataset.activation) - 1;
		if (!parseInt(cell.dataset.activation)) {
			cell.classList.remove("active");
		}
	}
}


// -----
// Controls:

function setWaveform(element) {
	PLAYBACK_STATE.waveform = element.id.substring(2);
	let spans = ELEMENTS.waveforms.getElementsByTagName("span");
	for (let i=0; i<spans.length; i++) {
		let span = spans[i];
		if (span === element) {
			span.classList.add("selected");
		} else {
			span.classList.remove("selected");
		}
	}
}

setWaveform(document.getElementById("w_triangle"));

function skipToStart() {
	ELEMENTS.song.selectionStart = 0;
	ELEMENTS.song.selectionEnd = 0;
}

const SHARED_SONG_OPTION = "shared";
let sharedSongContent = "";
let sharedSongKey = "";

const WELCOME_TEXT = `{Welcome to Tonality Pad!}

C D E F G A B C {Regular notes}

C C, C' C D E E, E D C {Use , or ' to jump down or up an octave}

C C'' C,,, A' B {...or more octaves}

C4 C8 D E F G2 C,4 D16 E F8 D B C1 {Rhythm: 1 = whole note, 2 = half note, etc.; unspecified = same as previous note}

A4 B R2 C4 D E8 F R G A1 {R for rests}

C4. B8 A4 G E2 D {Dotted rhythm}

[C4 B C1 / E4 D F E D2 / G4 G A G G2] {Multiple notes at once}

D4 D8 F# A F A B B4 Bb A2 {Sharp (#) and flat (b)}

F4 F B B@ B F | F1 {Accidentals continue until canceled by natural sign (@) or barline}

C4 C+ C- R Bb-- Bb- Bbo Bb+ R1 | {Fine pitch adjustments with + and -}

{These can be used to improve harmony:}
  [D /F#/A] {Bad harmony gets marked in gray}
  [D-/F#/A] {Better!}

| D4 D- D A+ A Ao A | D1 {Cancel fine adjustments with o or barline}

K(F#+A+) D4 F A D, | D F@ Ao D, | D F A K() D, F A {Key signature}

C,4 D E T(4=180) F G A B T(2=40) C D C1 {Set tempo (quarter note at 180bpm, half note at 40bpm, etc.)}

C,4 D E~ F G~ G A: B:: C::: C {Slurred or staccato articulation}

C8 D E F O C D E F {Reset the octave context with O}

C D E O2 F G G4 F O''8 F G O F1 {...or set a new octave/rhythm context by modifying O}

X8 X16 X X R X R X8 X16 X X R X R R2 R4 {X for a noise sound}

{Force a particular instrument with $ plus a letter:}
$s C D {s for Sine wave ‚óØ}
$t E F {t for Triangle wave ‚ñ≥}
$q G A {q for sQuare wave ‚ñ¢}
$p B C {p for Pulse wave ‚¨®}
$u G E {u for sUperpulse wave ‚úß}
$w D C {w for saWtooth wave ‚òÜ}
$ G A B C {Lone $ sign returns to the default instrument set by the buttons above}

{In summary, make sure to get the order right:}
Bb-''2.~
{
  1. Note letter: B
  2. Accidental: b
  3. Fine adjustment: -
  4. Octave shift: ''
  5. Note length: 2
  6. Length dots: .
  7. Articulation: ~
}

{About the hexagonal grid: This is the "Tonnetz" (Tone Network), first devised by Leonard Euler to depict pitch ratios involving multiples of 2, 3, and 5. While factors of 2 (octaves) are ignored, factors of 3 ("perfect fifths") are represented by moving horizontally across the grid, and factors of 5 ("major thirds") by moving along the "1-o'clock / 7-o'clock" axis. Thus, adjacent notes will form nice harmonies, while distant notes will sound bad together. Sharps/flats shift the pitch by 25:24, while pluses/minuses tweak it by the smaller interval of 81:80 (the so-called "syntonic comma"). With this notation we can represent all ratios involving 2, 3, and 5.}`;

ELEMENTS.song.value = WELCOME_TEXT;
refreshHighlights();

// -----
// Sounds:

function createPulseWaveform(audioContext, d, terms) {
	// https://en.wikipedia.org/wiki/Fourier_series#Table_of_common_Fourier_series
	let precision = 100000000;
	let real = new Float32Array(terms);
	let imag = new Float32Array(terms);
	real[0] = d;
	imag[0] = 0;
	for (let n=1; n<terms; n++) {
		real[n] = Math.round(precision*Math.sin(2*Math.PI*n*d)/(Math.PI*n))/precision;
		imag[n] = Math.round(precision*2*Math.pow(Math.sin(Math.PI*n*d),2)/(Math.PI*n))/precision;
	}
	return audioContext.createPeriodicWave(real, imag);
}

function createRecorder(stream) {
	if (!stream || !window.MediaRecorder) {
		ELEMENTS.recordButton.style.cursor = "not-allowed";
		ELEMENTS.recordButton.onclick = null;
		ELEMENTS.recordButton.title = "Your browser does not support audio recording.";
		return;
	}
	// https://developer.mozilla.org/en-US/docs/Web/API/AudioContext/createMediaStreamDestination
	let mediaRecorderChunks = [];
	let mediaRecorder = new MediaRecorder(stream);
	mediaRecorder.ondataavailable = (evt) => {
		mediaRecorderChunks.push(evt.data);
	};
	mediaRecorder.onstop = (evt) => {
		let blob = new Blob(mediaRecorderChunks, { type: "audio/ogg; codecs=vorbis" });
		let url = window.URL.createObjectURL(blob);
		let a = document.createElement("a");
		a.style = "display: none";
		a.href = url;
		a.download = "tune.ogg";
		document.body.appendChild(a);
		a.click();
		window.URL.revokeObjectURL(url);
		document.body.removeChild(a);
		mediaRecorderChunks = [];
	};
	return mediaRecorder;
}

const AUDIO = (function(){
	// http://stackoverflow.com/a/29641185
	let AudioContext = window.AudioContext || window.webkitAudioContext || window.audioContext;
	let audioCtx = AudioContext && new AudioContext;
	if (!audioCtx) {
		ELEMENTS.song.value = "Your browser doesn't support audio synthesis. Try one of the browsers listed here: https://caniuse.com/audio-api";
	}

	let recordingDestination = audioCtx.createMediaStreamDestination && audioCtx.createMediaStreamDestination();

	// Create buffer for white noise
	let bufferSize = 2 * audioCtx.sampleRate;
    let noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    let output = noiseBuffer.getChannelData(0);
	for (let i = 0; i<bufferSize; i++) {
	    output[i] = Math.random() * 2 - 1;
	}

	return {
		context: audioCtx,
		pulseWaveform: audioCtx && createPulseWaveform(audioCtx, 0.25, 30),
		superpulseWaveform: audioCtx && createPulseWaveform(audioCtx, 0.125, 30),
		pulseWaveformInv: audioCtx && createPulseWaveform(audioCtx, 0.75, 30),
		superpulseWaveformInv: audioCtx && createPulseWaveform(audioCtx, 0.875, 30),
		recordingDestination: recordingDestination,
		recorder: createRecorder(recordingDestination && recordingDestination.stream),
		noiseBuffer: noiseBuffer
	};
})();

function tone(frequency, type) {
	if (!AUDIO.context) {
		return void(0);
	}
    let gainNode = AUDIO.context.createGain();
	let oscillator = AUDIO.context.createOscillator();
	oscillator.connect(gainNode);
    oscillator.frequency.value = frequency;
    if (type === "pulse") {
		oscillator.setPeriodicWave(Math.random()>0.5 ? AUDIO.pulseWaveform : AUDIO.pulseWaveformInv);
	} else if (type === "superpulse") {
		oscillator.setPeriodicWave(Math.random()>0.5 ? AUDIO.superpulseWaveform : AUDIO.superpulseWaveformInv);
    } else {
    	oscillator.type = type;
    }
	gainNode.connect(AUDIO.context.destination);
	if (PLAYBACK_STATE.recording) {
		let recordingGainNode = AUDIO.context.createGain();
		recordingGainNode.gain.value = RECORDING_GAIN;
		gainNode.connect(recordingGainNode);
		recordingGainNode.connect(AUDIO.recordingDestination);
	}
	let gainValue = BASE_VOLUME * VOLUME_ADJUSTMENT[type];
	gainNode.gain.value = gainValue;
	oscillator.start();
	return {
		stop: function(){
			// Fade out for a short time after the note "officially" ends, to soften the popping sound that would otherwise result from abruptly dropping to 0.
			let currentTime = AUDIO.context.currentTime;
			gainNode.gain.setValueAtTime(gainValue, currentTime);
			let stopTime = currentTime + FADEOUT_MS/1000;
			gainNode.gain.linearRampToValueAtTime(0, stopTime);
			oscillator.stop(stopTime);
		}
	}
}

function noiseTone() {
	let gainNode = AUDIO.context.createGain();
	let whiteNoise = AUDIO.context.createBufferSource();
	whiteNoise.buffer = AUDIO.noiseBuffer;
	whiteNoise.loop = true;
	whiteNoise.connect(gainNode);
	gainNode.connect(AUDIO.context.destination);
	if (PLAYBACK_STATE.recording) {
		let recordingGainNode = AUDIO.context.createGain();
		recordingGainNode.gain.value = RECORDING_GAIN;
		gainNode.connect(recordingGainNode);
		recordingGainNode.connect(AUDIO.recordingDestination);
	}
	gainNode.gain.value = 1/24;
	whiteNoise.start();
	return whiteNoise;
}


// -----
// Dissonance analysis:

function gcd(a,b) {
    if (a < 0) a = -a;
    if (b < 0) b = -b;
    if (b > a) {let temp = a; a = b; b = temp;}
    while (true) {
        if (b == 0) return a;
        a %= b;
        if (a == 0) return b;
        b %= a;
    }
}

function Rat(num,den) {
    this.num = num;
    this.den = den;
    return this;
}
const ONE_RAT = new Rat(1,1);
const TWO_RAT = new Rat(2,1);
Rat.prototype.plus = function(x) {
    let g = gcd(this.den, x.den);
    let newNum = this.num*x.den + x.num*this.den;
    let newDen = this.den*x.den;
    return new Rat(newNum/g, newDen/g);
}
Rat.prototype.times = function(x) {
    let newNum = this.num * x.num;
    let newDen = this.den * x.den;
    let g = gcd(newNum, newDen);
    return new Rat(newNum/g, newDen/g);
}
Rat.prototype.pow = function(power) {
	let result = ONE_RAT;
	let a = power > 0 ? this : this.inverse();
	for (let i=0; i<Math.abs(power); i++) {
		result = result.times(a);
	}
	return result;
}
Rat.prototype.negate = function() {
    return new Rat(-this.num, this.den);
}
Rat.prototype.inverse = function() {
    if (this.num === 0) {
        throw "Div0 error";
    }
    return new Rat(this.den, this.num);
}
Rat.prototype.toString = function() {
    return this.num + "/" + this.den;
}
Rat.prototype.toFloat = function() {
    return this.num/this.den;
}
Rat.prototype.copy = function() {
    return new Rat(this.num, this.den);
}
Rat.prototype.eq = function(x) {
	return x.num === this.num && x.den === this.den;
}
Rat.prototype.gt = function(x) {
	return this.num*x.den > x.num*this.den;
}
Rat.prototype.lt = function(x) {
	return this.num*x.den < x.num*this.den;
}

const JUST_INTONATION_RAT = {
    C: new Rat(1,1), D: new Rat(9,8), E: new Rat(5,4), F: new Rat(4,3),
    G: new Rat(3,2), A: new Rat(5,3), B: new Rat(15,8)
};
const CHROMATIC_SEMITONE_RAT = new Rat(25,24);
const SYNTONIC_COMMA_RAT = new Rat(81,80);

function ratForNote(noteName) {
	let base = JUST_INTONATION_RAT[noteName[0].toUpperCase()];
	let pluses = noteName.match(/p/g);
	pluses = pluses ? pluses.length : 0;
	let minuses = noteName.match(/m/g);
	minuses = minuses ? minuses.length : 0;
	let fineAccidentals = pluses - minuses

	let sharps = noteName.match(/s/g);
	sharps = sharps ? sharps.length : 0;
	let flats = noteName.substring(1).match(/f/g);
	flats = flats ? flats.length : 0;
	let coarseAccidentals = sharps - flats;

	let rat = base
		.times(CHROMATIC_SEMITONE_RAT.pow(coarseAccidentals))
		.times(SYNTONIC_COMMA_RAT.pow(fineAccidentals))
	return octaveReduce(rat);
}

function octaveReduce(rat) {
	while (rat.gt(TWO_RAT) || rat.eq(TWO_RAT)) {
		rat = rat.times(TWO_RAT.inverse())
	}
	while (rat.lt(ONE_RAT)) {
		rat = rat.times(TWO_RAT);
	}
	return rat;
}

function pitchClass(noteName) {
	let sharps = noteName.match(/s/g);
	sharps = sharps ? sharps.length : 0;
	let flats = noteName.substring(1).match(/f/g);
	flats = flats ? flats.length : 0;
	let coarseAccidentals = sharps - flats;
	let base = WHITE_NOTES[noteName[0].toUpperCase()];
	let result = base + coarseAccidentals;
	while (result < 0) {
		result += 12;
	}
	while (result >= 12) {
		result -= 12;
	}
	return result;
}

function findPitchClassNeighborhood(noteName) {
	let home = pitchClass(noteName);
	return [
		home,
		(home + 7) % 12,
		(home + 5) % 12,
		(home + 4) % 12,
		(home + 9) % 12,
		(home + 3) % 12,
		(home + 8) % 12
	];
}

function findRatNeighborhood(noteName) {
	let home = ratForNote(noteName);
	return [
		// must be in the same order:
		home,
		octaveReduce(home.times(new Rat(3,1))),
		octaveReduce(home.times(new Rat(1,3))),
		octaveReduce(home.times(new Rat(5,1))),
		octaveReduce(home.times(new Rat(5,3))),
		octaveReduce(home.times(new Rat(3,5))),
		octaveReduce(home.times(new Rat(1,5)))
	];
}

// Return a list of token indices where a simultaneous note is dissonant, i.e. where there is a note adjacent on the grid which is equivalent up to enharmonic spelling and fine accidentals.
function computeDissonances(compiled) {
	let dissonances = [];
	for (let i=0; i<compiled.length; i++) {
		let note = compiled[i];
		let startTime = note[0];
		let endTime = note[1];
		let noteName = note[3];
		let tokenIndex = note[4];
		if (noteName === "R" || noteName === "X") {
			continue;
		}
		let pcNeighborhood = findPitchClassNeighborhood(noteName);
		let ratNeighborhood = findRatNeighborhood(noteName);
		for (let j=0; j<compiled.length; j++) {
			if (j === i) {
				continue;
			}
			let otherNote = compiled[j];
			let otherStartTime = otherNote[0];
			let otherEndTime = otherNote[1];
			let otherNoteName = otherNote[3];
			if (otherStartTime >= endTime || otherEndTime <= startTime || otherNoteName === "R" || otherNoteName === "X") {
				continue;
			}
			let otherPitchClass = pitchClass(otherNoteName);
			let otherRat = ratForNote(otherNoteName);
			let pcMatch = pcNeighborhood.indexOf(otherPitchClass);
			if (pcMatch !== -1) {
				if (!otherRat.eq(ratNeighborhood[pcMatch])) {
					dissonances.push(tokenIndex);
				}
			}
		}
	}
	return dissonances;
}


// -----
// Parsing / compilation:

function parseOctaveMarkers(octaveMarkers) {
	let octaveUps = octaveMarkers.match(/'/g);
	octaveUps = octaveUps ? octaveUps.length : 0;
	let octaveDowns = octaveMarkers.match(/,/g);
	octaveDowns = octaveDowns ? octaveDowns.length : 0;
	let writtenOctaveAdjustment = octaveUps - octaveDowns;
	return writtenOctaveAdjustment;
}

function indexAwareSplit(string, regex) {
	let split = [];
	let indices = [];
	let matches = string.matchAll(regex);
	let match;
	let position = 0;
	while ((match = matches.next()) && !match.done) {
		split.push(string.substring(position, match.value.index));
		indices.push(position);
		position = match.value.index + match.value[0].length;
	}
	split.push(string.substring(position));
	indices.push(position);
	return {split:split, indices:indices};
}

function separateStandalones(tokensRaw, indicesRaw) {
	let tokens = [];
	let indices = [];
	for (let i=0; i<tokensRaw.length; i++) {
		let tokenRaw = tokensRaw[i];
		let indexRaw = indicesRaw[i];
		let resultingTokens = [];
		let string = "";
		let indicesWithinToken = [];
		let lastStart = 0;
		for (let j=0; j<tokenRaw.length; j++) {
			let c = tokenRaw[j];
			if (STANDALONE_CHARS.includes(c)) {
				resultingTokens.push(string);
				indicesWithinToken.push(lastStart);
				resultingTokens.push(c);
				indicesWithinToken.push(j);
				lastStart = j+1;
				string = "";
			} else {
				string += c;
			}
		}
		resultingTokens.push(string);
		indicesWithinToken.push(lastStart);
		for (let k=0; k<resultingTokens.length; k++) {
			let resultingToken = resultingTokens[k];
			if (resultingToken) {
				tokens.push(resultingToken);
				indices.push(indicesWithinToken[k] + indexRaw);
			}
			
		}
	}
	return {split:tokens, indices:indices};
}

function compileNotation(notation) {
	let splitAndIndicesRaw = indexAwareSplit(notation, /\s+/g);
	let tokensRaw = splitAndIndicesRaw.split;
	let tokenIndicesRaw = splitAndIndicesRaw.indices;
	if (tokensRaw && tokensRaw[0] === "") {
		tokensRaw = tokensRaw.slice(1);
		tokenIndicesRaw.slice(1);
	}
	let splitAndIndices = separateStandalones(tokensRaw, tokenIndicesRaw);
	let tokens = splitAndIndices.split;
	let indices = splitAndIndices.indices;
	let compiled = [];
	let invalidTokens = [];

	let wholeNotesPerMinute = 20; // default if no T() is specified
	let cursor = 0;
	let lastNoteLength = 4;
	let lastNoteValue = 0; // 0 = middle c, 1 = c#, etc
	let measureSignature = {};
	let forcedInstrument = "";

	let polyphonyStack = []; // contains arrays with the preceding 6 variables in that order
	let keySignature = {};
	let commentingLevel = 0;

	for (let i=0; i<tokens.length; i++) {
		let token = tokens[i];
		if (!token) {
			// Do nothing
		} else if (token === "}") {
			if (commentingLevel <= 0) {
				invalidTokens.push(i);
			} else {
				commentingLevel--;
			}
		} else if (token === "{") {
			commentingLevel++;
		} else if (commentingLevel) {
			// Do nothing
		} else if (token[0] === "T") {
			let inner = token.slice(2, -1);
			let parts = inner.split("=");
			if (!inner || parts.length !== 2) {
				invalidTokens.push(i);
				continue;
			}
			let beat = parts[0];
			let baseBeat = parseInt(beat);
			let dotCount = beat.endsWith(".") ? beat.match(/\./g).length : 0;
			let bpm = parseInt(parts[1]);
			if (isNaN(baseBeat) || isNaN(bpm)) {
				invalidTokens.push(i);
				continue;
			}
			wholeNotesPerMinute = bpm * (2 - Math.pow(2, -dotCount)) / baseBeat;
		} else if (token[0] === "K") {
			let inner = token.slice(2, -1);
			let noteInKS;
			let ksCoarse = 0;
			let ksFine = 0;
			keySignature = {};
			if (inner) {
				for (let k=0; k<inner.length; k++) {
					let c = inner[k];
					if ("ABCDEFG".includes(c)) {
						keySignature[noteInKS] = [ksCoarse, ksFine];
						ksCoarse = 0;
						ksFine = 0;
						noteInKS = c;
					} else {
						if (c === "#") {
							ksCoarse++;
						} else if (c === "b") {
							ksCoarse--;
						} else if (c === "+") {
							ksFine++;
						} else if (c === "-") {
							ksFine--;
						}
					}
				}
				keySignature[noteInKS] = [ksCoarse, ksFine];
			}
		} else if (token[0] === "$") {
			if (token.length > 1) {
				if (token.length === 2 && INSTRUMENT_LETTERS[token[1]]) {
					forcedInstrument = token[1];
				} else {
					invalidTokens.push(i);
					continue;
				}
			} else {
				forcedInstrument = "";
			}
		} else if (token === "|") {
			measureSignature = {};
		} else if (token === "[") {
			polyphonyStack.push([wholeNotesPerMinute, cursor, lastNoteLength, lastNoteValue, JSON.stringify(measureSignature), forcedInstrument]);
		} else if (token === "/") {
			if (!polyphonyStack.length) {
				invalidTokens.push(i);
				continue;
			}
			// Return to the state as of the start of the polyphony
			let topOfStack = polyphonyStack[polyphonyStack.length-1];
			wholeNotesPerMinute = topOfStack[0];
			cursor = topOfStack[1];
			lastNoteLength = topOfStack[2];
			lastNoteValue = topOfStack[3];
			measureSignature = JSON.parse(topOfStack[4]);
			forcedInstrument = topOfStack[5];
		} else if (token === "]") {
			if (polyphonyStack.length < 1) {
				invalidTokens.push(i);
				continue;
			}
			polyphonyStack.pop();
			// All values are now as of the last line of the polyphony, even if the lines were not the same length, which means that the next note may start while some of the lines are still playing.
		} else {
			let parsedNote = token.match(NOTE_REGEX);
			//console.log("!!!!", token, parsedNote);
			if (!parsedNote || parsedNote.length !== 7 || parsedNote.slice(1).join("") !== token) {
				invalidTokens.push(i);
				continue;
			}
			let noteLetter = parsedNote[1];
			let accidentals = parsedNote[2] || "";
			let octaveMarkers = parsedNote[3] || "";
			let noteLength = parsedNote[4] || "";
			let dots = parsedNote[5] || "";
			let articulation = parsedNote[6] || "";

			if (noteLength && noteLength[0] === "0") {
				invalidTokens.push(i);
				continue;
			}
			if (noteLength) {
				lastNoteLength = parseInt(noteLength);
			}
			let staccatos = articulation.match(/:/g);
			staccatos = staccatos ? staccatos.length : 0;

			let noteLengthMsUndotted = 60000/(wholeNotesPerMinute*lastNoteLength);
			let totalLengthMs = noteLengthMsUndotted * (2 - Math.pow(2, -dots.length));
			let activeLengthMs = totalLengthMs * Math.pow(2, -staccatos);
			let breakFactor =
				articulation === "~" || noteLetter === "R" ? 0 :
				noteLetter === "X" ? NOISE_BREAK :
				NOTE_BREAK;
			let breakLengthMs = Math.min(BREAK_MAX_MS, activeLengthMs * breakFactor);
			let startTime = cursor;
			let endTime = cursor + (activeLengthMs - breakLengthMs);

			if (noteLetter !== "O") {
				cursor += totalLengthMs;
			}

			if (noteLetter === "O") {
				let writtenOctaveAdjustment = parseOctaveMarkers(octaveMarkers);
				lastNoteValue = 12*writtenOctaveAdjustment;
			} else if (noteLetter === "R" || noteLetter === "X") {
				compiled.push([startTime, endTime, 0, noteLetter, i, indices[i], indices[i]+token.length, ""]);
			} else {
				let ksAccidentals = keySignature[noteLetter];
				let coarseAccidentals = 0;
				if (accidentals.includes("#") || accidentals.includes("b") || accidentals.includes("@")) {
					let sharps = accidentals.match(/#/g);
					sharps = sharps ? sharps.length : 0;
					let flats = accidentals.match(/b/g);
					flats = flats ? flats.length : 0;
					coarseAccidentals = sharps - flats;
					if (!measureSignature[noteLetter]) {
						measureSignature[noteLetter] = [coarseAccidentals, null];
					} else {
						measureSignature[noteLetter][0] = coarseAccidentals;
					}
				} else if (measureSignature[noteLetter] && measureSignature[noteLetter][0] !== null) {
					coarseAccidentals = measureSignature[noteLetter][0];
				} else if (ksAccidentals) {
					coarseAccidentals = ksAccidentals[0];
				}

				let fineAccidentals = 0;
				if (accidentals.includes("+") || accidentals.includes("-") || accidentals.includes("o")) {
					let pluses = accidentals.match(/\+/g);
					pluses = pluses ? pluses.length : 0;
					let minuses = accidentals.match(/-/g);
					minuses = minuses ? minuses.length : 0;
					fineAccidentals = pluses - minuses;
					if (!measureSignature[noteLetter]) {
						measureSignature[noteLetter] = [null, fineAccidentals];
					} else {
						measureSignature[noteLetter][1] = fineAccidentals;
					}
				} else if (measureSignature[noteLetter] && measureSignature[noteLetter][1] !== null) {
					fineAccidentals = measureSignature[noteLetter][1];
				} else if (ksAccidentals) {
					fineAccidentals = ksAccidentals[1];
				}

				let naiveValue = WHITE_NOTES[noteLetter] + coarseAccidentals;
				let bounds = findBounds(lastNoteValue, naiveValue);
				let upperBound = bounds[1];
				let lowerBound = bounds[0];
				let lowerDiff = lastNoteValue - lowerBound;
				let upperDiff = upperBound - lastNoteValue;
				let adjustedValue = upperDiff<=lowerDiff ? upperBound : lowerBound;

				let writtenOctaveAdjustment = parseOctaveMarkers(octaveMarkers);
				adjustedValue += (12 * writtenOctaveAdjustment);
				lastNoteValue = adjustedValue;
				let octaveAdjustment = (adjustedValue - naiveValue)/12;

				let pitch = MIDDLE_C *
					Math.pow(2, octaveAdjustment) *
					JUST_INTONATION[noteLetter] *
					Math.pow(CHROMATIC_SEMITONE, coarseAccidentals) *
					Math.pow(SYNTONIC_COMMA, fineAccidentals);
				let noteName = noteLetter.toLowerCase() + 
					(coarseAccidentals ? new Array(1+Math.abs(coarseAccidentals)).join(coarseAccidentals>0 ? "s" : "f") : "") +
					(fineAccidentals ? new Array(1+Math.abs(fineAccidentals)).join(fineAccidentals>0 ? "p" : "m") : "");
				compiled.push([startTime, endTime, pitch, noteName, i, indices[i], indices[i]+token.length, forcedInstrument]);
			}
		}
	}
	return [compiled, invalidTokens];
}


// -----
// Playback:

function findBounds(anchor, floating) {
	let lower = -Infinity;
	let upper = Infinity;
	for (let v=anchor-12; v<=anchor+12; v++) {
		if ((v - floating) % 12 === 0) {
			if (v <= anchor) {
				lower = v;
			}
			if (v >= anchor) {
				upper = v;
				break;
			}
		}
	}
	return [lower, upper];
}

function chooseWaveform(instrumentLetter) {
	return !instrumentLetter ? PLAYBACK_STATE.waveform : INSTRUMENT_LETTERS[instrumentLetter];
}

// `compiled` is an array of notes given as 8-element arrays [0:startTime, 1:endTime, 2:frequency, 3:noteName, 4:tokenIndex, 5:notationStart, 6:notationEnd, 7:forcedInstrument]
// (Times are given in milliseconds)
// tokenIndex = the sequence order of the token representing this note (0 for first, etc.)
// notationStart, notationEnd = the character position where the token begins and ends
function play(compiled, cursorPosition) {
	// Find the first token that ends after the cursorPosition. Start playback at the startTime of that note. If there is no such note, start from 0.
	let cursorNote = false;
	let nextAfterCursor = Infinity;
	for (let i=0; i<compiled.length; i++) {
		let note = compiled[i];
		let notationStart = note[5];
		let notationEnd = note[6];
		if (notationEnd > cursorPosition) {
			if (notationStart < nextAfterCursor) {
				nextAfterCursor = notationStart;
				cursorNote = note;
			}
		}
	}
	let playbackStartTime = cursorNote ?
		Math.max(0,cursorNote[0]-0.000000001) : // allowance for floating-point errors
		0;
	let lastEndTime = 0;
	if (PLAYBACK_STATE.recording) {
		AUDIO.recorder.start();
	}
	let tiedGroup = [];
	for (let i=0; i<compiled.length; i++) {
		let note = compiled[i];
		let startTime = note[0];
		let endTime = note[1];
		lastEndTime = Math.max(endTime, lastEndTime);
		let frequency = note[2];
		let noteName = note[3];
		let tokenIndex = note[4];
		let forcedInstrument = note[7];
		let duration = endTime - startTime;
		if (startTime < playbackStartTime) {
			continue;
		}

		let nextNote = i+1<compiled.length ? compiled[i+1] : null;
		let tiedToNext =
			nextNote &&
			endTime === nextNote[0] && // start time of next note
			frequency === nextNote[2] &&
			noteName === nextNote[3] &&
			(forcedInstrument || "") === (nextNote[7] || "");
		// If the current note is part of a tie, its timeout should do highlighting but no sound.
		let isInTie = tiedToNext || tiedGroup.length;

		PLAYBACK_STATE.timeouts.push(createNoteTimeout(startTime-playbackStartTime, frequency, duration, noteName, tokenIndex, forcedInstrument, !isInTie, true));

		if (!tiedToNext && tiedGroup.length) {
			// But if the current note is the last in the tied group, also set a timeout that does sound (for the entire duration of the tie) but no highlighting.
			let startTimeOfGroup = tiedGroup[0][0];
			let durationOfGroup = endTime - startTimeOfGroup;
			tiedGroup = [];
			PLAYBACK_STATE.timeouts.push(createNoteTimeout(startTimeOfGroup-playbackStartTime, frequency, durationOfGroup, noteName, tokenIndex, forcedInstrument, true, false));
		}
		if (tiedToNext) {
			tiedGroup.push(note);
		}
	}
	PLAYBACK_STATE.timeouts.push(setTimeout(function(){
		ELEMENTS.playButton.innerText = "‚ñ∂Ô∏è";
		PLAYBACK_STATE.playing = false;
		ELEMENTS.playControls.classList.remove("playing");
		if (PLAYBACK_STATE.recording) {
			stopRecording();
		}
	}, lastEndTime-playbackStartTime));
}

function createNoteTimeout(timeoutStartFromNow, frequency, duration, noteName, tokenIndex, forcedInstrument, doSound, doHighlights) {
	return setTimeout(function(){
		if (doHighlights) {
			activateCell(noteName);
			setHighlighting(tokenIndex, 1);
		}
		let oscillator =
			!doSound || noteName === "R" ? null :
			noteName === "X" ? noiseTone() :
			tone(frequency, chooseWaveform(forcedInstrument));
		if (oscillator) {
			PLAYBACK_STATE.tones[tokenIndex] = oscillator;
		}
		PLAYBACK_STATE.timeouts.push(setTimeout(function(){
			if (doHighlights) {
				deactivateCell(noteName);
				setHighlighting(tokenIndex, 0);
			}
			if (oscillator) {
				oscillator.stop();
				delete PLAYBACK_STATE.tones[tokenIndex];
			}
		}, duration));
	}, timeoutStartFromNow);
}

function copy(array) {
	let result = [];
	for (let i=0; i<array.length; i++) {
		result.push(array[i]);
	}
	return result;
}

function stop() {
	PLAYBACK_STATE.playing = false;
	ELEMENTS.playButton.innerText = "‚ñ∂Ô∏è";
	ELEMENTS.playControls.classList.remove("playing");
	for (let i=0; i<PLAYBACK_STATE.timeouts.length; i++) {
		clearTimeout(PLAYBACK_STATE.timeouts[i]);
	}
	for (let t in PLAYBACK_STATE.tones) {
		PLAYBACK_STATE.tones[t].stop();
	}
	PLAYBACK_STATE.timeouts = [];
	PLAYBACK_STATE.tones = {};
	let actives = copy(document.getElementsByClassName("active"));
	for (let j=0; j<actives.length; j++) {
		if (actives[j]) {
			actives[j].classList.remove("active");
			if (actives[j].dataset.activation) {
				actives[j].dataset.activation = 0;
			}
		}
	}
	if (PLAYBACK_STATE.recording) {
		stopRecording();
	}
}

function startRecording() {
	if (!PLAYBACK_STATE.playing) {
		PLAYBACK_STATE.recording = true;
		playSong();
		ELEMENTS.recordButton.style.display = "none";
		ELEMENTS.recordIndicator.style.display = null;
	}
}

function stopRecording() {
	setTimeout(function(){
		AUDIO.recorder.stop();
		PLAYBACK_STATE.recording = false;
		ELEMENTS.recordButton.style.display = null;
		ELEMENTS.recordIndicator.style.display = "none";
	}, FADEOUT_MS);
}

function playSong() {
	if (!PLAYBACK_STATE.playing) {
		refreshHighlights();
		ELEMENTS.playButton.innerText = "‚èπ";
		let textarea = document.getElementById("song");
		let songNotation = textarea.value;
		let cursorPosition = textarea.selectionStart;
		let compilation = compileNotation(songNotation);
		let songCompiled = compilation[0];
		let compilationErrors = compilation[1];
		displayErrors(compilationErrors);
		let dissonances = computeDissonances(songCompiled);
		displayDissonances(dissonances);
		play(songCompiled, cursorPosition);
		ELEMENTS.playControls.classList.add("playing");
		PLAYBACK_STATE.playing = true;
	} else {
		stop();
	}
}


// -----
// Link sharing:

const ALPHABET_CODE = {
	"{": 	"10111001",
	"}": 	"1011101001110111",
	"A": 	"01010",
	"B": 	"1101",
	"C": 	"1100",
	"D": 	"1111",
	"E": 	"1110",
	"F": 	"01001",
	"G": 	"01000",
	"R": 	"011001",
	"O": 	"011000",
	"X": 	"010111",
	"#": 	"10111000",
	"b": 	"10010101",
	"@": 	"10010100",
	"+": 	"10010111",
	"o": 	"10010110",
	"-": 	"01110011",
	"'": 	"10000",
	",": 	"01111",
	"0": 	"10111010110",
	"1": 	"01101",
	"2": 	"10110",
	"3": 	"010110",
	"4": 	"10101",
	"5": 	"101110100111010",
	"6": 	"10100",
	"7": 	"10111010011111",
	"8": 	"10011",
	"9": 	"10111010011110",
	".": 	"0111000",
	"~": 	"011100100",
	"[": 	"0111011",
	"/": 	"100100",
	"]": 	"0111010",
	"|": 	"101111",
	"T": 	"10111010000",
	"K": 	"01110010111",
	"(": 	"01110010110",
	")": 	"01110010101",
	"=": 	"01110010100",
	"$": 	"101110100110",
	"s": 	"101110100101",
	"t": 	"101110100100",
	"q": 	"101110100011",
	"w": 	"101110101000",
	"u": 	"101110100010",
	"p": 	"10111010111",
	"f": 	"1011101010011",
	"m": 	"1011101010010",
	":": 	"10111011",
	"*": 	"10111010011100",
	" ":	"00",
	"\n": 	"10001",
	"\t": 	"1011101001110110",
	"": 	"10111010101" // reserved for new symbols
};
const ALPHABET_CODE_INV = (function(){
	let result = {};
	for (symbol in ALPHABET_CODE) {
		result[ALPHABET_CODE[symbol]] = symbol;
	}
	return result;
})();

// vibe-coded:
function extractUTF(bits, startIndex) {
    if (startIndex >= bits.length) {
        throw new Error("Start index out of bounds");
    }
    let pos = startIndex;
    // Determine UTF-8 byte length from leading bits (including the terminating 0)
    let leadingOnes = 0;
    while (pos < bits.length && bits[pos] === 1 && leadingOnes < 5) {
        leadingOnes++;
        pos++;
    }

    let bytesNeeded;
    if (leadingOnes === 0) {
        // 0xxxxxxx -> 1 byte (ASCII)
        bytesNeeded = 1;
    } else if (leadingOnes >= 2 && leadingOnes <= 4) {
        // 110xxxxx -> 2, 1110xxxx -> 3, 11110xxx -> 4
        bytesNeeded = leadingOnes;
    } else {
        throw new Error("Invalid UTF-8 starting byte (overlong or invalid prefix)");
    }

    let totalBits = bytesNeeded * 8;
    if (startIndex+totalBits > bits.length) {
        throw new Error("Not enough bits for complete UTF-8 character");
    }

    let charBits = bits.slice(startIndex, startIndex + totalBits);
    let bytes = [];
    for (let i=0; i<bytesNeeded; i++) {
        let b = 0;
        for (let j=0; j<8; j++) {
            b = (b << 1) | charBits[i*8 + j];
        }
        bytes.push(b);
    }

    let character = new TextDecoder("utf-8", { fatal: true }).decode(new Uint8Array(bytes));
    return {
        character: character,
        size: totalBits
    };
}

function bytesToBits(bytes) {
    let bits = [];
    for (let i=0; i<bytes.length; i++) {
    	let byte = bytes[i];
        for (let j=7; j>=0; j--) {
            bits.push((byte >> j) & 1);
        }
    }
    return bits;
}

function bitsToBytes(bits) {
	// bits.length must be a multiple of 8
	let bytes = new Uint8Array(bits.length/8);
	for (let i=0; i<bits.length; i+=8) {
		bytes[i/8] = bits[i]*128 + bits[i+1]*64 + bits[i+2]*32 + bits[i+3]*16 
					+ bits[i+4]*8 + bits[i+5]*4 + bits[i+6]*2 + bits[i+7]*1;
	}
	return bytes;
}

function encode(songText) {
	let bits = [0,0,0];
	let commentingLevel = 0;
	let charArray = Array.from(songText);
	for (let i=0; i<charArray.length; i++) {
		let cha = charArray[i];
		let charEncoding;
		if (commentingLevel) {
			charEncoding = bytesToBits(new TextEncoder().encode(cha));
		} else {
			if (!ALPHABET_CODE[cha]) {
				return false;
			}
			charEncoding = ALPHABET_CODE[cha].split("").map(x => parseInt(x));
		}
		for (let j=0; j<charEncoding.length; j++) {
			bits.push(charEncoding[j]);
		}
		if (cha === "{") {
			commentingLevel++;
		} else if (cha === "}" && commentingLevel) {
			commentingLevel--;
		}
	}
	let paddingCount = (8-((bits.length)%8))%8
	for (let j=0; j<paddingCount; j++) {
		bits.push(1);
	}
	let paddingCountBits = [
		(paddingCount&4) >> 2,
		(paddingCount&2) >> 1,
		(paddingCount&1) >> 0
	];
	// prepend padding count:
	bits[0] = paddingCountBits[0];
	bits[1] = paddingCountBits[1];
	bits[2] = paddingCountBits[2];

	return btoa(Array.from(bitsToBytes(bits), (byte) => String.fromCodePoint(byte)).join(""))
		.replaceAll("+","-")
		.replaceAll("/","_")
		.replaceAll("=","");
}

function decode(encoded) {
	let bits = bytesToBits(
		Array.from(
			atob(encoded.replaceAll("-","+").replaceAll("_","/")),
			c => c.charCodeAt(0)
		)
	);
  	let paddingCount = 4*bits[0] + 2*bits[1] + 1*bits[2];
  	let latest = "";
  	let commentingLevel = 0;
  	let decoded = "";
  	for (let i=3; i<bits.length-paddingCount; i++) {
  		let next;
  		if (commentingLevel) {
  			let extracted = extractUTF(bits, i);
  			next = extracted.character;
  			i += (extracted.size-1);
  		} else {
  			latest += bits[i];
  			next = ALPHABET_CODE_INV[latest];
  			if (next) {
  				latest = "";
  			}
  		}
  		if (next) {
			if (next === "{") {
				commentingLevel++;
			} else if (next === "}" && commentingLevel) {
				commentingLevel--;
			}
			decoded += next;
		}
  	}
  	return decoded;
}

function shareLink() {
	if (!PLAYBACK_STATE.playing) {
		let encoded = encode(ELEMENTS.song.value);
		if (!encoded) {
			alert("Song contains syntax errors; fix these before sharing");
		} else {
			window.location.hash = encoded;
			navigator.clipboard.writeText(window.location.href);
			ELEMENTS.copiedTooltip.classList.add("visible");
			setTimeout(function(){
				ELEMENTS.copiedTooltip.classList.remove("visible");
			}, 1000);
		}
	}
}

function fetch(url, callback) {
	let xhr = new XMLHttpRequest();
	xhr.open("GET", url);
	xhr.onreadystatechange = function () {
		if (xhr.readyState === 4) {
			callback(xhr);
		}
	};
	xhr.send();
}

function fetchGist(gistID, callback) {
	fetch("https://api.github.com/gists/" + gistID, function(xhr) {
		if (xhr.status === 200 || xhr.status === 304) {
			let response = JSON.parse(xhr.responseText);
			// we only care about the first file
			let file = response.files[Object.keys(response.files)[0]];
			if (file && file.content) {
				callback(file.content);
				return;
			} else {
				console.log("github unexpected", xhr);
			}
		} else if (xhr.status === 403 || xhr.status === 404) {
			console.log("github 4xx", xhr);
		} else {
			console.log("github error", xhr);
		}
		callback("{ Error: Could not fetch song from GitHub Gist. Make sure the song is available at https://gist.github.com/" + gistID + " }");
	});
}

function displayFetchedContent(key, content) {
	ELEMENTS.song.value = content;
	sharedSongContent = content;
	sharedSongKey = key;
	refreshHighlights();
	skipToStart();
}

function refreshHash() {
	let hash = window.location.hash;
	if (hash && hash.length>1) {
		let hashSlice = hash.slice(1);
		let hashSplit = hashSlice.split("/");
		if (hashSplit.length === 1) {
			// content is encoded directly in the hash
			try {
				let decoded = decode(hashSplit[0]);
				displayFetchedContent(hashSlice, decoded);
			} catch(e) {
				console.log("Decoding error:", e);
				window.location.hash = "";
				alert("Invalid link!");
			}
		} else if (hashSplit[0].charAt(0) === "g" && hashSplit[1]) {
			// fetch content from GitHub Gist
			if (hashSlice === sharedSongKey) {
				displayFetchedContent(hashSlice, sharedSongContent);
			} else {
				fetchGist(hashSplit[1], function(content) {
					displayFetchedContent(hashSlice, content);
				});
			}
		} else if (hashSplit[0] === "raw") {
			// uncompressed base64
			try {
				let decoded = new TextDecoder().decode(
					Uint8Array.from(
						atob(hashSplit[1]
							.replaceAll("-","+")
							.replaceAll("_","/")
						), (m) => m.codePointAt(0)
					)
				);
				displayFetchedContent(hashSlice, decoded);
			} catch(e) {
				console.log("Decoding error:", e);
				window.location.hash = "";
				alert("Invalid link!");
			}
		} else {
			window.location.hash = "";
			alert("Invalid link!");
		}
	} else {
		displayFetchedContent("", WELCOME_TEXT);
	}
}

document.body.onload = refreshHash;
window.onhashchange = refreshHash;

function shareOnGithub() {
	const url = new URL("https://github.com/tonalitypad/tonalitypad-data-test/issues/new");
	url.searchParams.set("body", ELEMENTS.song.value);
	url.toString();
	window.open(url.toString(), "_blank", "noopener,noreferrer");
}

if (window !== window.parent) {
	// Hide permalink button when embedded in iframe
	ELEMENTS.shareLinkButton.style = "display: none";
}

</script>
</body>
</html>
